; QUESTION 1
; Takes a single integer argument N and returns the Nth Padovan number.
(defun PAD (N)
    ; Base case: if N is 0, 1, or 2, return 1.
    (cond ((or (= N 0) (= N 1) (= N 2)) 1)
          ; Otherwise, recursively calculate Nth term of PAD as defined by
          ; the spec. Note that 1 is added to each integer in the formula
          ; to account for the 0th position.
          (T (+ (PAD (- N 2)) (PAD (- N 3))))
    )
)


; QUESTION 2
; Takes a single numeric argument N and returns the number of additions
; required by the PAD function to compute the Nth Padovan number.
(defun SUMS (N)
    ; Base case: if N is 0, 1, or 2, there are no additions.
    (cond ((or (= N 0) (= N 1) (= N 2)) 0)
          ; Otherwise, the total number of sums is equal to the number
          ; of sums generated by (PAD (- N 2)) plus the number of sums
          ; generated by (PAD (- N 3)) plus one (the current N's sum).
          (T (+ (SUMS (- N 2)) (SUMS (- N 3)) 1))
    )
)


; QUESTION 3
; Takes a single argument TREE that represents a tree and returns an anonymized
; tree with the same structure, but where all symbols and numbers in the tree
; are replaced by a question mark.
(defun ANON (TREE)
    ; Base case 1: if the tree is empty, return the empty list
    (cond ((null TREE) '())
    ; Base case 2: if the tree is a single node, return a single ?
    ((atom TREE) '?)
        ; Otherwise, recursively create the resulting tree by attaching the
        ; the ANON car to the ANON cdr.
        (T (cons (ANON (car TREE)) (ANON (cdr TREE))))
    )
)
